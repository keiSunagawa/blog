'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','parent'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/blog/tags/helm/','title':"helm",'parent':"Tags",'content':""});index.add({'id':1,'href':'/blog/posts/helm-template/','title':"Helm Template Tips",'parent':"Posts",'content':"この記事は過去に Qiita で書いたものの転載です\nHelm https://helm.sh/\nHelmはk8sにおけるパッケージマネージャーのようなもです\nk8sのService, Deployment, ConfigMap, etcをひとつのまとまり(Chartと呼ばれる)として構成し、それらのk8sクラスタへのinstall/update/deleteなどの責務を担当してくれます\n公式や誰かの作ったChartをinstallするほか、自分たちの作ってるアプリケーションのChartを作成することでマニフェストファイルの共通化やdeploy/rollbackを簡単にすることができます\n当記事では後者の用途を前提として進めます\nHelmの基礎を理解頂いてる方は Template までスキップして頂けると、今回の本題はそちらですので\nInit Helmのインストール手順は公式を参照、以下はHelm/k8sをinstallしている前提で進めます\nChartのスケルトン生成 $ helm create first-app Creating first-app $ tree first-app/ first-app/ ├── Chart.yaml ├── charts ├── templates │ ├── NOTES.txt │ ├── _helpers.tpl │ ├── deployment.yaml │ ├── ingress.yaml │ ├── service.yaml │ └── tests │ └── test-connection.yaml └── values.yaml 3 directories, 8 files helm create \u0026lt;chart name\u0026gt; でChartのスケルトンを生成できます\n生成されるファイル/ディレクトリ   Chart.yaml\nChartの概要、対象のk8s API versionなどが記載されている\n  charts\nSubchart(自身のChartが依存するChart)が含まれるディレクトリ\nSubchartについての説明はこの記事では行いません(自分もまだ使ったことのない機能なので)\n  templates\n今回の本題、マニフェストファイルのTemplateが格納されているディレクトリ\nマニフェストファイルについての詳しい説明は後述\n  values.yaml\nTemplateで使える値のyaml\nこのファイルではデフォルト値を定義しておき、install/update時に環境に応じたファイルを渡すことでここで定義した値を差し替えることができる\n  デバッグ $ helm install . --debug --dry-run\nとすることで作成中のTemplateに変数を展開したマニフェストファイルをみることができます\nTemplate Chartを構成するk8sマニフェストはTemplateと呼ばれるファイルによって生成されます\nTemplateはその名の通りマニフェストファイルのテンプレートで変数を埋め込んだり、関数を呼び出すことで環境に応じて変更される部分を抽象化することができます\nこの項目ではTemplateで使える様々な構文について説明します\n基本的な構文 Templateにおいて何れの構文も {{ }} に囲まれて表記されます\n{{ }} 以外の部分はただのk8sマニフェストです、つまりただのyamlです\n(ちなみに Go言語のTemplate機能 から派生しているようです)\n中括弧内側の前後にダッシュ {{- -}} をつけることができ、前後の改行を含めた空白文字をトリムします\nhoge:{{- $piyo:=\u0026#34;aaa\u0026#34;}}- \u0026#34;fuga\u0026#34;# ↓↓展開されると↓↓hoge:- \u0026#34;fuga\u0026#34;コメント /* */ で囲まれた部分はコメント構文になります\n通常のプログラミング言語のコメントと同様で展開時には無視されます\n{{- /* a comment */ -}} 変数 変数には二種類あり、ルートオブジェクトからpathを辿って呼び出されるものとローカル変数の参照です\n「ルートオブジェクト」「ローカル変数」については勝手に名前をつけたものなので公式ではありません\n変数はそのまま参照先の値が展開されます\nルートオブジェクト Templateで呼び出せる様々な事前定義オブジェクトやvalues.yamlに定義された値を取り出すための Values オブジェクトへの参照を持つrootです\n後述する _helpers.tpl 内で定義できる名前付きtemplateや、range構文では呼び出し時に渡した値がルートオブジェクトとなります\n{{ . }} がルートオブジェクトそのものを表す記法となり、ここからpathを記載していきます\n# templates/service.yamlapiVersion:v1kind:Servicemetadata:name:{{.Values.myapp.serviceName}}---# values.yamlmyapp:serviceName:\u0026#34;myservice\u0026#34;Valuesの他にもルートオブジェクトには様々な事前定義オブジェクトがあり以下のドキュメントが一覧となります\nhttps://helm.sh/docs/chart_template_guide/#built-in-objects\nローカル変数 各Templateファイル内で変数を定義することができます\n{{- $volumeName:=\u0026#34;myvolume\u0026#34;-}}volumeMounts:- mountPath:/etc/{{$volumeName}}/name:{{$volumeName}}volumes:- name:{{$volumeName}}見ての通りだとは思いますが {{- $volumeName := \u0026quot;myvolume\u0026quot; -}} で変数に束縛し {{ $volumeName }} で展開できます\n関数 Template構文内では事前定義された様々な関数を使うことができます\n残念ながら定義の一覧のドキュメントは存在しないようです\nただし、Helm側で定義されている関数の他、以下の関数の多くが実装されているそうです\nhttp://masterminds.github.io/sprig/\nまた、事前定義オブジェクトの中にも定義されている関数があります( .Files.get など)\n関数の呼び出しは 関数名 引数1 [引数2 ...] という形になります\n関数はパイプ(|) を使うことでチェインすることができます\n{{ .Files.get \u0026quot;files/main.cf\u0026quot; | nindent 4}} 以下よく使う関数を抜粋して紹介します\n紹介の表記は 関数名 \u0026lt;引数1の型\u0026gt; [\u0026lt;引数2の型\u0026gt; ...] という形にします\nリファレンスがないので型といっても数値か文字列かオブジェクトとか、といった程度になってしまいますが…\n  nindent \u0026lt;numer\u0026gt; \u0026lt;string\u0026gt;\n第2引数に渡した文字列の各行の先頭に第1引数の数値分だけ半角スペース(つまりインデント)を埋め込みます\nyaml等の文字列を展開する場合にこの関数でインデントを調整することができます\n  toYaml\nオブジェクトをyaml形式で展開してくれます\nvalues.yamlに記載されているyamlを直接マニフェストファイルに展開したい場合などにこの関数を使います\n  # values.yamltest:hoge:fuga:piyo# deployment.yamlexpand:{{- nindent2(toYaml.Values.test)}}# ↓↓展開されると↓↓expand:hoge:fuga:piyo include \u0026lt;string\u0026gt; \u0026lt;object\u0026gt;\n_helpers.tpl に定義した名前付きtemplateを展開します\n第2引数のオブジェクトは名前付きtemplate側でのルートオブジェクトとして扱われ、基本的にはルートオブジェクトをそのまま渡すパターン {{ inculude \u0026quot;fugafuga\u0026quot; . }} が多いです\n以下のサンプルではあえてルートオブジェクト以外のものを渡してみます  # values.yamltest:hoge:fuga:piyo# _helpers.tpl{{- define\u0026#34;fugafuga\u0026#34;-}}- {{toYaml.-}}- {{toYaml.-}}{{- end}}# deployment.yamlexpand:{{- include\u0026#34;fugafuga\u0026#34;.Values.test.hoge|nindent2}}# ↓↓展開されると↓↓expand:- fuga:piyo- fuga:piyo tpl \u0026lt;string\u0026gt; \u0026lt;object\u0026gt;\n第1引数の文字列をTemplateとして解釈し、第2引数をルートオブジェクトとして展開します\n_helpers.tpl に定義しているものは include で展開すればTemplateとして解釈されるので\nこちらは外部ファイルを取ってきたあとに適用する場合が多いです\nTemplate構文を展開するだけなのでyaml以外の文字列でも適用は可能です  # values.yamlnginxValues:nginxUser:\u0026#34;nginx\u0026#34;# files/nginx.confuser{{.nginxUser}};http{# いろいろ}# configmap.yamldata:nginx.conf:|{{tpl(.Files.Get\u0026#34;files/nginx.conf\u0026#34;).Values.nginxValues|nindent4}}# ↓↓展開されると↓↓data:nginx.conf:| user nginx;http{# いろいろ} .Files.Get \u0026lt;string\u0026gt;\n外部からファイルを文字列として取り込みます\n第1引数はファイルパスでChartのルートディレクトリ( Chart.yaml の置いてあるディレクトリ)からの相対パスを記載します  アクション 関数のほか、Templateを制御するためいくつかのキーワードが用意されています\n一般的なプログラミング言語でいう if や for などにあたります、これをHelmではアクションと呼びます\nif/else 特に語ることのない一般的なif文です\n値が以下の場合にはすべて false として判定されます\nhttps://helm.sh/docs/chart_template_guide/#if-else\nA pipeline is evaluated as false if the value is: a boolean false a numeric zero an empty string a nil (empty or null) an empty collection (map, slice, tuple, dict, array) 注意点としてダッシュ付きの中括弧を使用することを推奨するくらいです\nspec: replicas: {{ if .Values.safety -}} 2 {{- else -}} 1 {{- end -}} with 引数に渡したオブジェクトをルートオブジェクトとしたスコープを展開できます\n引数に渡したオブジェクトが if/else アクションで紹介したfalseにあたる値の場合はwithブロック自体が展開されません、つまり簡易的な if としても使用できます\nwithブロック内で .Files オブジェクトなどの事前定義オブジェクトを参照する場合は外側で変数に束縛しましょう、このテクニックは range アクションでも使用できます\n# values.yamlconfigPaths:nginxConfPath:\u0026#34;files/nginx.conf\u0026#34;# configmap.yaml{{- $files=.Files-}}data:{{- with.Values.configPaths-}}nginx.conf:|{{$files.get.nginxConfPath|nindent4}}{{- end-}}range 引数に渡した配列でループを回します\nループ内のスコープでは配列の値自体がルートオブジェクトとなります\n# values.yamlconfigPaths:- key:nginx.confpath:\u0026#34;files/nginx.conf\u0026#34;- key:postfix.main.cfpath:\u0026#34;files/main.cf\u0026#34;# comfigmap.yaml{{- $files=.Files-}}data:{{- range.Values.configPaths-}}{{.key }}:|{{$files.get.path|nindent4}}{{- end-}}# ↓↓展開されると↓↓data:nginx.conf:| # nginx.confの内容main.cf:| # main.cfの内容template _helpers.tpl に定義してある名前付きtemplateを展開します\nただし、include関数と違いルートオブジェクトを渡すことができません\n_helpers.tpl Chart内で共通で使うことのできるテンプレートスニペットを定義します、これは「名前付きテンプレート」と呼ばれます\nvalues.yaml が差し替え可能な変数、ローカル変数が定義したTemplateファイル内でのみ使える変数、_helpers.tplはチャート内で自由に使える変数、という形に捉えることができます\ndefine アクションを使うことで名前付きテンプレートを定義することができます\nもちろん、テンプレートなので定義内で変数を展開したり、関数やアクションを使用することもできます\n(ただし、呼び出し側で想定通りのオブジェクトを渡す必要があります、templateアクションではなくincluede関数を使う必要もあります)\n{{- define \u0026quot;myapp.namespace\u0026quot; -}} {{ .Chart.Name }}-space {{- end }}  Helm Template構文における基本的な構文は以上となります\nひとまずこれだけ覚えていれば問題なくHelm Templateを読み書きできると思います\n少し特殊なものが多いのでGo Templateを触れていない(自分もそうだったのですが)人間から見るとなかなかつらいもの、特に関数周りは公式ドキュメントに記載や一覧がないのでとっつきにくいと感じたので今回の記事を書かせて頂きました\nこの記事が誰かの役に立つことを願います\n"});index.add({'id':2,'href':'/blog/tags/k8s/','title':"k8s",'parent':"Tags",'content':""});index.add({'id':3,'href':'/blog/','title':"Kerfume Blog",'parent':'','content':""});index.add({'id':4,'href':'/blog/posts/','title':"Posts",'parent':"Kerfume Blog",'content':""});index.add({'id':5,'href':'/blog/tags/','title':"Tags",'parent':"Kerfume Blog",'content':""});index.add({'id':6,'href':'/blog/categories/','title':"Categories",'parent':"Kerfume Blog",'content':""});})();