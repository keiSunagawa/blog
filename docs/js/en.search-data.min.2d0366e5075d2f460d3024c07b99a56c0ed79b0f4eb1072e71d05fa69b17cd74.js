'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','parent'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/tags/containerd/','title':"containerd",'parent':"Tags",'content':""});index.add({'id':1,'href':'/tags/docker/','title':"docker",'parent':"Tags",'content':""});index.add({'id':2,'href':'/tags/k8s/','title':"k8s",'parent':"Tags",'content':""});index.add({'id':3,'href':'/posts/eks-containerd-k8s-120/','title':"k8s 1.20の更新後のEKSのコンテナランタイムについて",'parent':"Posts",'content':"背景 k8s 1.20よりdocker用のCRIであるdockershimがサポートされなくなるので\nそれに伴いeksではなにをすればいいのか、コンテナランタイムの代替えとしては何を利用するのかを調べた\nコンテナランタイム 文字通りコンテナを実行するモジュール\n現在の選択肢としてはdocker, containerd, CRI-Oなどがある\nk8sではコンテナランタイムに対してCRIという規約に従ったgrpcサーバを要求する\nCRI(ContainerRuntimeInterface) k8sがコンテナランタイムに要求するインタフェースの規約\nコンテナランタイムはこれに則ったgrpcサーバを用意する必要がある\nk8s自体元々(1.12より前)は利用できるコンテナランタイムがdockerのみだったが\n他のランタイムも利用できるようにするためにこの規約を定めた\nが、当然docker自身はこの規約に則ったインタフェースは持っていないため\ndocker用のCRIとしてk8s側がdockershimというものを用意していた\nk8s 1.20 Dockershimが非推奨になった\n以後Dockershimのメンテがされなくなるので他のコンテナランタイムを利用してね、と公式からのアナウンスがある\ncontainerdやCRI-OはCRIがネイティブサポートされている\non EKS 今回の本題\nEKSではどう対応されるのかを調べる\n2020/12/24時点\nAmazonLinux最適化AMIではコンテナランタイムは引き続きdockerだった\n$ kube get nodes -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME ip-xxx-xxx-xxx-xxx.ap-northeast-1.compute.internal Ready \u0026lt;none\u0026gt; 114m v1.18.9-eks-d1db3c xxx.xxx.xxx.xxx \u0026lt;none\u0026gt; Amazon Linux 2 4.14.209-160.335.amzn2.x86_64 docker://19.3.6 Bottlerocket最適化AMIの場合containerdらしいけどこちらは\ncluster managed node groupを利用している場合は現在選択できない\nFargateの場合はcontainerdが採用されているようだ\n$ kube get nodes -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME fargate-ip-xxx-xxx-xxx-xxx.ap-northeast-1.compute.internal Ready \u0026lt;none\u0026gt; 28s v1.18.8-eks-7c9bda xxx.xxx.xxx.xxx \u0026lt;none\u0026gt; Amazon Linux 2 4.14.209-160.335.amzn2.x86_64 containerd://1.3.2 現時点でのAmazonLinux最適化AMIでのcontainerdに関する声明はとくにないが\neksでのlatest k8s versionが 1.18系であることから焦って対応する必要がなく、様子見でよさそうだ\n"});index.add({'id':4,'href':'/posts/','title':"Posts",'parent':"くらげ.log",'content':""});index.add({'id':5,'href':'/tags/','title':"Tags",'parent':"くらげ.log",'content':""});index.add({'id':6,'href':'/','title':"くらげ.log",'parent':'','content':""});index.add({'id':7,'href':'/tags/gatekeeper/','title':"gatekeeper",'parent':"Tags",'content':""});index.add({'id':8,'href':'/posts/gatekeeper-memo/','title':"Gatekeeper Memo",'parent':"Posts",'content':"この記事は FOLIO Advent Calendar 2020 20日目の記事です\n前回の記事でhelmを交えたargoCDの話をすると言ったな、あれは嘘だ\n調べてて面白そうだったので今回は Gatekeeper で利用されるpolicy記述言語Regoについてのおぼえ書きということにさせていただきます\nGatekeeper policy記述言語Regoを利用してk8s上のマニフェストに対してpolicyを設定できるツール\n実装的にはk8s側ではAdmission Webhooks, Regoを利用するためにOPA, それぞれを利用して作られています\nこれによってk8sマニフェストに対してpolicy制限を実現し、特定のキーの利用の強制や逆に制限をかけることができる\n 今回はそのpolicyを記述するための言語Regoについて書きます\n実際にGatekeeperを触ってからの方がwhyを理解しやすいと思うのでREADMEの How to Use Gatekeeperを実施してから\n読むのを推奨します\nRego policy記述言語\n一般的な逐次処理を記載していくタイプの言語とは違い\n宣言的に条件を記載していき、結果値を得ることを目的としている\nprologとか定理証明系で使われている言語の流れを汲んでいるらしい(よく知らない)\nplaygroundも存在し、以降のコードスニペットはすべてplayground上で動くものを記載している\n変数 x := 3 regoの変数には利用方法が二種類ある\nひとつは一般的なプログラミング言語同様値を束縛するためのもの\nもうひとつは少し曲者で未束縛の変数を利用した場合にその変数が取りうる可能性を持つ値の範囲で束縛する\nこの場合「束縛」という表現は正しくないと思うが、自分的な理解しやすい表現なのであえてこう表現する\nx := [1, 2, 3] y { some i x[i] i == 0 # 1や2を指定してもtrue } 上記の例では i は x のindexの範囲の値を取るため i は0もしくは1もしくは2となる\nルール構文 \u0026lt;ruleName\u0026gt; { .. } に関しては今の所説明をしていないが後述する、一旦は一般的なプログラミング言語でいう\nブロック構文に名前がついたものとでも思っていただければいい\nRegoでは代入式を除く殆どの式が値の絞り込みを行うためのもので、上記の例でもルール y の2行目 x[i] の時点では\ni は0~2を取りうる可能性があるが3行目 i == 0 の時点で i は 0 で確定し、以降それ以外の値とはmatchしなくなる\nRule Regoはpolicyを記述する言語でpolicyはいくつかのルールの集合として定義される\nルールとは入力値を利用し、複数の式を適用した結果、取りうる残りの値を返す関数のようなものだ\nRegoではそれぞれの行の条件式は、それまでの行で検証された変数の取りうる値すべての範囲で検証され、trueの値の範囲のみ\n次の行を評価する\nすべてがfalseと評価された場合に取りうる結果がなくなったと判断され、未定義値を返す、これは戻り値のjsonとしては undefined として表現される\nuser_permission := { \u0026#34;bob\u0026#34;: [\u0026#34;view\u0026#34;], \u0026#34;alice\u0026#34;: [\u0026#34;view\u0026#34;, \u0026#34;edit\u0026#34;, \u0026#34;create\u0026#34;] } exists { user_permission[input.user_name] } permission[pm] { pm := user_permission[input.user_name][_] not pm == \u0026#34;view\u0026#34; } 一つ目のルール exists は結果の取りうる値が一つの場合のルールだ\ninputは入力jsonの値を参照している、入力 user_name が user_permission に\n含まれる値であれば、結果値は一つの配列型の値として決定する\n結果値が一つの値に決定されている場合は、その値がbool型のfalseでない場合を除き\n全てtrueとして出力される\n二つ目のルール permission では変数 pm が取りうる値を全て返すルールだ\n[_] は未束縛の変数を利用する場合の簡略記法で、簡略化しない場合以下のものと同じだ\npermission[pm] { some i pm := user_permission[input.user_name][i] 明示的に変数指定をする場合は i を再利用できるが、今回は i には関心がないので簡略記法を使った\n変数 pm には変数 i が取りうる範囲で適用した場合の結果値が入る\n入力jsonを { \u0026quot;user_name\u0026quot;: \u0026quot;alice\u0026quot; } と想定した場合\n一行目の式では i には0~2の値が pm は \u0026quot;view\u0026quot;, \u0026quot;edit\u0026quot;, \u0026quot;create\u0026quot; の範囲で値を取ることがわかる\n二行目の式ではさらに pm の範囲を絞り込み view 以外の値をとることを示している\nつまり最終的な結果値 pm の取りうる範囲は \u0026quot;edit\u0026quot;, \u0026quot;create\u0026quot; となり、出力jsonではこの配列を返す\n出力をobjectとすることで複数の値を含むこともできる\npermission[{\u0026#34;kind\u0026#34;: pm, index: i}] { some i pm := user_permission[input.user_name][i] not pm == \u0026#34;view\u0026#34; } # objectの配列を返すことができる #\u0026#34;permission\u0026#34;: [ # { # \u0026#34;index\u0026#34;: 1, # \u0026#34;kind\u0026#34;: \u0026#34;edit\u0026#34; # }, # { # \u0026#34;index\u0026#34;: 2, # \u0026#34;kind\u0026#34;: \u0026#34;create\u0026#34; # } # ], ルールはひとつのファイルに複数定義し、ルールから別のルールを参照することができるが\nGatekeeperを利用する場合は violation ルール名で定義したものがエントリーポイント的に扱われる\nRegoでのPolicyの定義は複数のルールによって構成されるが、結果的に出力値がallowなのかdenyなのかということはRego側では関心を持たない\nつまり、undefined が出力されようが false が出力されようがRegoにとってそれはあくまでただの出力値であり\nそれをallowなのかdenyなのかを判断するのは利用側(多くの場合はOPA)ということになる\nsome Keyword some は未束縛の変数を定義するキーワードだ\nRegoにはスコープの概念が存在し、内側のスコープから外側の変数を参照することができる\nRegoでは見束縛の変数であることが非常に重要なため、誤って外側の変数を参照しないよう、some キーワードで明示的に宣言することができる\ni := 1 x := [1, 2, 3] y { some i # この行をコメントアウトした場合 i == 1 に決定されているため、3行目でfalseとなる x[i] i == 0 # 1や2を指定してもtrue } 内包表記 x := [1, 2, 3] # array comprehensions xx := [inc | inc := x[_] + 1] # object comprehensions xbj := {k: v| some i k := x[i] v := x[i] + 1 } # set comprehensions xset := {inc | inc := x[_] + 1} 配列やobject, setには内包表記が存在する\n内包表記自体は一般的なプログラミング言語と同じ動作をするが、式部分はルール同様の式が記載できる\nまた、setとobjectの内包表記がどちらも {..} で、混同しないように注意\nこれはsetのリテラルが { 1, 2, 3 } といった形になっているため ややこしい\n Gatekeeperを利用する場合でのRegoはこれらの構文だけ覚えておけば大丈夫かもしれない\n"});index.add({'id':9,'href':'/tags/opa/','title':"opa",'parent':"Tags",'content':""});index.add({'id':10,'href':'/tags/rego/','title':"rego",'parent':"Tags",'content':""});index.add({'id':11,'href':'/tags/helm/','title':"helm",'parent':"Tags",'content':""});index.add({'id':12,'href':'/posts/helm-template/','title':"Helm Template Tips",'parent':"Posts",'content':"この記事は過去に Qiita で書いたものの転載です\nHelm https://helm.sh/\nHelmはk8sにおけるパッケージマネージャーのようなもです\nk8sのService, Deployment, ConfigMap, etcをひとつのまとまり(Chartと呼ばれる)として構成し、それらのk8sクラスタへのinstall/update/deleteなどの責務を担当してくれます\n公式や誰かの作ったChartをinstallするほか、自分たちの作ってるアプリケーションのChartを作成することでマニフェストファイルの共通化やdeploy/rollbackを簡単にすることができます\n当記事では後者の用途を前提として進めます\nHelmの基礎を理解頂いてる方は Template までスキップして頂けると、今回の本題はそちらですので\nInit Helmのインストール手順は公式を参照、以下はHelm/k8sをinstallしている前提で進めます\nChartのスケルトン生成 $ helm create first-app Creating first-app $ tree first-app/ first-app/ ├── Chart.yaml ├── charts ├── templates │ ├── NOTES.txt │ ├── _helpers.tpl │ ├── deployment.yaml │ ├── ingress.yaml │ ├── service.yaml │ └── tests │ └── test-connection.yaml └── values.yaml 3 directories, 8 files helm create \u0026lt;chart name\u0026gt; でChartのスケルトンを生成できます\n生成されるファイル/ディレクトリ   Chart.yaml\nChartの概要、対象のk8s API versionなどが記載されている\n  charts\nSubchart(自身のChartが依存するChart)が含まれるディレクトリ\nSubchartについての説明はこの記事では行いません(自分もまだ使ったことのない機能なので)\n  templates\n今回の本題、マニフェストファイルのTemplateが格納されているディレクトリ\nマニフェストファイルについての詳しい説明は後述\n  values.yaml\nTemplateで使える値のyaml\nこのファイルではデフォルト値を定義しておき、install/update時に環境に応じたファイルを渡すことでここで定義した値を差し替えることができる\n  デバッグ $ helm install . --debug --dry-run\nとすることで作成中のTemplateに変数を展開したマニフェストファイルをみることができます\nTemplate Chartを構成するk8sマニフェストはTemplateと呼ばれるファイルによって生成されます\nTemplateはその名の通りマニフェストファイルのテンプレートで変数を埋め込んだり、関数を呼び出すことで環境に応じて変更される部分を抽象化することができます\nこの項目ではTemplateで使える様々な構文について説明します\n基本的な構文 Templateにおいて何れの構文も {{ }} に囲まれて表記されます\n{{ }} 以外の部分はただのk8sマニフェストです、つまりただのyamlです\n(ちなみに Go言語のTemplate機能 から派生しているようです)\n中括弧内側の前後にダッシュ {{- -}} をつけることができ、前後の改行を含めた空白文字をトリムします\nhoge:{{- $piyo:=\u0026#34;aaa\u0026#34;}}- \u0026#34;fuga\u0026#34;# ↓↓展開されると↓↓hoge:- \u0026#34;fuga\u0026#34;コメント /* */ で囲まれた部分はコメント構文になります\n通常のプログラミング言語のコメントと同様で展開時には無視されます\n{{- /* a comment */ -}} 変数 変数には二種類あり、ルートオブジェクトからpathを辿って呼び出されるものとローカル変数の参照です\n「ルートオブジェクト」「ローカル変数」については勝手に名前をつけたものなので公式ではありません\n変数はそのまま参照先の値が展開されます\nルートオブジェクト Templateで呼び出せる様々な事前定義オブジェクトやvalues.yamlに定義された値を取り出すための Values オブジェクトへの参照を持つrootです\n後述する _helpers.tpl 内で定義できる名前付きtemplateや、range構文では呼び出し時に渡した値がルートオブジェクトとなります\n{{ . }} がルートオブジェクトそのものを表す記法となり、ここからpathを記載していきます\n# templates/service.yamlapiVersion:v1kind:Servicemetadata:name:{{.Values.myapp.serviceName}}---# values.yamlmyapp:serviceName:\u0026#34;myservice\u0026#34;Valuesの他にもルートオブジェクトには様々な事前定義オブジェクトがあり以下のドキュメントが一覧となります\nhttps://helm.sh/docs/chart_template_guide/#built-in-objects\nローカル変数 各Templateファイル内で変数を定義することができます\n{{- $volumeName:=\u0026#34;myvolume\u0026#34;-}}volumeMounts:- mountPath:/etc/{{$volumeName}}/name:{{$volumeName}}volumes:- name:{{$volumeName}}見ての通りだとは思いますが {{- $volumeName := \u0026quot;myvolume\u0026quot; -}} で変数に束縛し {{ $volumeName }} で展開できます\n関数 Template構文内では事前定義された様々な関数を使うことができます\n残念ながら定義の一覧のドキュメントは存在しないようです\nただし、Helm側で定義されている関数の他、以下の関数の多くが実装されているそうです\nhttp://masterminds.github.io/sprig/\nまた、事前定義オブジェクトの中にも定義されている関数があります( .Files.get など)\n関数の呼び出しは 関数名 引数1 [引数2 ...] という形になります\n関数はパイプ(|) を使うことでチェインすることができます\n{{ .Files.get \u0026quot;files/main.cf\u0026quot; | nindent 4}} 以下よく使う関数を抜粋して紹介します\n紹介の表記は 関数名 \u0026lt;引数1の型\u0026gt; [\u0026lt;引数2の型\u0026gt; ...] という形にします\nリファレンスがないので型といっても数値か文字列かオブジェクトとか、といった程度になってしまいますが…\n  nindent \u0026lt;numer\u0026gt; \u0026lt;string\u0026gt;\n第2引数に渡した文字列の各行の先頭に第1引数の数値分だけ半角スペース(つまりインデント)を埋め込みます\nyaml等の文字列を展開する場合にこの関数でインデントを調整することができます\n  toYaml\nオブジェクトをyaml形式で展開してくれます\nvalues.yamlに記載されているyamlを直接マニフェストファイルに展開したい場合などにこの関数を使います\n  # values.yamltest:hoge:fuga:piyo# deployment.yamlexpand:{{- nindent2(toYaml.Values.test)}}# ↓↓展開されると↓↓expand:hoge:fuga:piyo include \u0026lt;string\u0026gt; \u0026lt;object\u0026gt;\n_helpers.tpl に定義した名前付きtemplateを展開します\n第2引数のオブジェクトは名前付きtemplate側でのルートオブジェクトとして扱われ、基本的にはルートオブジェクトをそのまま渡すパターン {{ inculude \u0026quot;fugafuga\u0026quot; . }} が多いです\n以下のサンプルではあえてルートオブジェクト以外のものを渡してみます  # values.yamltest:hoge:fuga:piyo# _helpers.tpl{{- define\u0026#34;fugafuga\u0026#34;-}}- {{toYaml.-}}- {{toYaml.-}}{{- end}}# deployment.yamlexpand:{{- include\u0026#34;fugafuga\u0026#34;.Values.test.hoge|nindent2}}# ↓↓展開されると↓↓expand:- fuga:piyo- fuga:piyo tpl \u0026lt;string\u0026gt; \u0026lt;object\u0026gt;\n第1引数の文字列をTemplateとして解釈し、第2引数をルートオブジェクトとして展開します\n_helpers.tpl に定義しているものは include で展開すればTemplateとして解釈されるので\nこちらは外部ファイルを取ってきたあとに適用する場合が多いです\nTemplate構文を展開するだけなのでyaml以外の文字列でも適用は可能です  # values.yamlnginxValues:nginxUser:\u0026#34;nginx\u0026#34;# files/nginx.confuser{{.nginxUser}};http{# いろいろ}# configmap.yamldata:nginx.conf:|{{tpl(.Files.Get\u0026#34;files/nginx.conf\u0026#34;).Values.nginxValues|nindent4}}# ↓↓展開されると↓↓data:nginx.conf:| user nginx;http{# いろいろ} .Files.Get \u0026lt;string\u0026gt;\n外部からファイルを文字列として取り込みます\n第1引数はファイルパスでChartのルートディレクトリ( Chart.yaml の置いてあるディレクトリ)からの相対パスを記載します  アクション 関数のほか、Templateを制御するためいくつかのキーワードが用意されています\n一般的なプログラミング言語でいう if や for などにあたります、これをHelmではアクションと呼びます\nif/else 特に語ることのない一般的なif文です\n値が以下の場合にはすべて false として判定されます\nhttps://helm.sh/docs/chart_template_guide/#if-else\nA pipeline is evaluated as false if the value is: a boolean false a numeric zero an empty string a nil (empty or null) an empty collection (map, slice, tuple, dict, array) 注意点としてダッシュ付きの中括弧を使用することを推奨するくらいです\nspec: replicas: {{ if .Values.safety -}} 2 {{- else -}} 1 {{- end -}} with 引数に渡したオブジェクトをルートオブジェクトとしたスコープを展開できます\n引数に渡したオブジェクトが if/else アクションで紹介したfalseにあたる値の場合はwithブロック自体が展開されません、つまり簡易的な if としても使用できます\nwithブロック内で .Files オブジェクトなどの事前定義オブジェクトを参照する場合は外側で変数に束縛しましょう、このテクニックは range アクションでも使用できます\n# values.yamlconfigPaths:nginxConfPath:\u0026#34;files/nginx.conf\u0026#34;# configmap.yaml{{- $files=.Files-}}data:{{- with.Values.configPaths-}}nginx.conf:|{{$files.get.nginxConfPath|nindent4}}{{- end-}}range 引数に渡した配列でループを回します\nループ内のスコープでは配列の値自体がルートオブジェクトとなります\n# values.yamlconfigPaths:- key:nginx.confpath:\u0026#34;files/nginx.conf\u0026#34;- key:postfix.main.cfpath:\u0026#34;files/main.cf\u0026#34;# comfigmap.yaml{{- $files=.Files-}}data:{{- range.Values.configPaths-}}{{.key }}:|{{$files.get.path|nindent4}}{{- end-}}# ↓↓展開されると↓↓data:nginx.conf:| # nginx.confの内容main.cf:| # main.cfの内容template _helpers.tpl に定義してある名前付きtemplateを展開します\nただし、include関数と違いルートオブジェクトを渡すことができません\n_helpers.tpl Chart内で共通で使うことのできるテンプレートスニペットを定義します、これは「名前付きテンプレート」と呼ばれます\nvalues.yaml が差し替え可能な変数、ローカル変数が定義したTemplateファイル内でのみ使える変数、_helpers.tplはチャート内で自由に使える変数、という形に捉えることができます\ndefine アクションを使うことで名前付きテンプレートを定義することができます\nもちろん、テンプレートなので定義内で変数を展開したり、関数やアクションを使用することもできます\n(ただし、呼び出し側で想定通りのオブジェクトを渡す必要があります、templateアクションではなくincluede関数を使う必要もあります)\n{{- define \u0026quot;myapp.namespace\u0026quot; -}} {{ .Chart.Name }}-space {{- end }}  Helm Template構文における基本的な構文は以上となります\nひとまずこれだけ覚えていれば問題なくHelm Templateを読み書きできると思います\n少し特殊なものが多いのでGo Templateを触れていない(自分もそうだったのですが)人間から見るとなかなかつらいもの、特に関数周りは公式ドキュメントに記載や一覧がないのでとっつきにくいと感じたので今回の記事を書かせて頂きました\nこの記事が誰かの役に立つことを願います\n"});index.add({'id':13,'href':'/posts/helm-tips/','title':"Helm Tips",'parent':"Posts",'content':"この記事は FOLIO Advent Calendar 2020 8日目の記事です\nFOLIOでは現在k8sを利用した新しいアプリケーション基盤を検証しています\nその中でk8sマニフェストを管理する上で欠かせないツール Helm についての知見を少しだけ共有しようと思います\nHelmって？ https://helm.sh/\nk8s上で動くパッケージマネージャ\nパッケージマネージャとはあるinfraの上で動くアプリケーションの\nインストール/アンインストールの管理などを行ってくれるソフトウェアのことを指します\nk8sというinfraの上でhelmというパッケージマネージャーが扱う「アプリケーション」は\nマニフェストファイルの集合となります\nhelmの世界ではパッケージはChartと呼ばれ、Chartリポジトリと呼ばれるhttp(s) serverにて管理されます\n標準では stableリポジトリ が用意されていますが\nユーザ側で用意した独自リポジトリも使用することが可能です\nHelmのChart構造やtemplate構文については以下の記事を参照ください\nhttps://keisunagawa.github.io/blog/posts/helm-template/\nLocal Chart helmはChartリポジトリからChartをインストールする他、localに存在するChartをディレクトリ指定で\n直接インストールすることも可能です\nこの方法は検証段階や、privateなChartリポジトリを建てる環境が存在しない場合などに役に立ちます\nInstall Tips helm Chartは helm install \u0026lt;release名\u0026gt; \u0026lt;chart名\u0026gt; コマンドによってk8sクラスタ上へインストールします\nまたインストール済みのChartについては helm upgrade コマンドでversionを更新することができます\n\u0026lt;release名\u0026gt; が違う場合は同じChartを複数インストールすることも可能です、ただしこの場合別名Chart同士でresource名の\nコンフリクトが発生しないことを前提としています\nversionというのはChart自身のversionのことでdocker imageのversionなどはChartのversionもしくはinstall時に\n引き渡す values.yaml の値によって決定されます、つまりChartの内容次第ということになります\nhelm upgrade --install とすることでinstall操作とupgrade操作を同時に行えます\nこれは新規Chartの場合install、インストール済みChartの場合はupgradeを行うというコマンドになります\nLocal Chartは helm install \u0026lt;release名\u0026gt; \u0026lt;chart dir\u0026gt; とすることでインストールすることができます\n以下install(upgrade)時によく使う引数をいくつかpickupします\n   flag      --create-namespace -nで指定したnamespaceが存在しない場合自動的に作成します   --atomic 何れかのマニフェスト適用に失敗した場合、install(upgrade)コマンド発行前の状態に戻します   --timeout install(upgrade)タイムアウトまでの時間を設定します外部リソースと連動したk8s resourceを発行するChartなどはタイムアウト値を伸ばすことを推奨します   --wait Podリソースなどが稼働状態になるのまでwaitしますただし、timeout時間までに稼働状態にならなかった場合はfailとなります   --values -f 利用するvalues.yamlを引き渡します複数引き渡すことも可能で、その場合同一キーは後勝ちとなります    依存Chart Chartは他のChartへ依存することができ、そのChartをインストールした場合は依存Chartも一緒にインストールされます\n依存定義はChart.yamlに記載されます(古いChartであれば requirements.yaml というファイルに記載されていますが、こちらは現在 deprecated です)\n何も指定しない場合、依存Chartは常にインストールされますが、condition もしくは tags キーを利用することでユーザ側に利用の有無を移譲することができます\n依存chartの条件については少し複雑なので以下のソースを参照しながら説明します\nよければvalues.yamlの値を書き換え、実際の挙動を確認してください\nhttps://github.com/keiSunagawa/helm-chart-playground/tree/master/dependency-example\ncondition https://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/Chart.yaml#L9\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/values.yaml#L2\ndependencies:- name:sub-chart-1version:\u0026#34;0.1.0\u0026#34;repository:\u0026#34;file://../sub-chart-1\u0026#34;condition:subChart1.enabledvaluesの値がboolであるキーを指定することで依存の利用有無を制御できます\n純粋なbool値のみを利用できnotやor/and演算を利用することはできません\nキーに紐づく値がnullの場合、キーが存在しない場合はtrueとして判定されます\nまた、カンマ区切りで複数の値を指定することができ、その場合は先頭から順に検査され\nnullでない一番最初の値 が利用されます\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/Chart.yaml#L18\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/values.yaml#L7\ncondition:subChart3.enabled,subChart3.devこの場合は subChart3.enabled がnullである場合は subChart3.dev が代わりに参照されます\nどちらのキーもnullだった場合はtrueとして判定されます\ntags https://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/Chart.yaml#L13\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/values.yaml#L4\n- name:sub-chart-2version:\u0026#34;0.1.0\u0026#34;repository:\u0026#34;file://../sub-chart-2\u0026#34;tags:- subChart2valuesの値がboolであるキーを配列で渡すことで condition より比較的複雑な条件分岐ができます\nvalues.yaml の tags.xxx のキーを参照し、対象キーがnullまたはtrueであった場合に依存Chartがインストールされます\n複数指定することもでき、複数指定した場合は以下の条件に従いインストールされます\n(公式ドキュメントが見当たらなかったため、v3.1.2 で検証した結果を載せています)\n インストールされる  何れかのキーがtrueの場合 すべてのキーがnullの場合   インストールされない  falseのキーが存在し、他のキーがnullの場合 全てのキーがfalseの場合    マニフェストの検証 helm template コマンドを利用することでk8sクラスタへChartをインストールすることなくマニフェストの検証をすることができます\n-f で本番環境で利用する values.yaml を引き渡せば本番適用時のものとほぼ同様のマニフェストを取得することができます\nhelm template コマンドはtemplateが正しいyamlに展開されなかった場合にfailします\nこの場合は --debug 引数を与えてあげることで不正なyamlを確認することができます\n出力は純粋なyamlになるので、yq などを利用して検証を行うことができます\n# Kindの一覧を取得する $ helm template . | yq r -d\u0026#39;*\u0026#39; --printMode pv - \u0026#39;kind\u0026#39; | uniq kind: ServiceAccount kind: Service kind: Deployment kind: Pod  終わりに helmはk8sを使う上で欠かせないツールです\n今回紹介した機能の他にもライフサイクルhookとなる helm hook や、インストールしたChartをロールバックする\n機能などが提供されており、単なるパッケージマネージャ以上の働きを期待することができます\nその他、FOLIO Advent Calendar 2020 20日目にてArgoCDというk8sで動くCDツールの話を\n書く予定ですが、ArgoCDとhelmを連携させることでさらに強力なツールとなるので、よければぜひそちらの記事も読んでいただけると幸いです。\n"});index.add({'id':14,'href':'/categories/','title':"Categories",'parent':"くらげ.log",'content':""});})();