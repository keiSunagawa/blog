'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','parent'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/blog/tags/helm/','title':"helm",'parent':"Tags",'content':""});index.add({'id':1,'href':'/blog/posts/helm-template/','title':"Helm Template Tips",'parent':"Posts",'content':"この記事は過去に Qiita で書いたものの転載です\nHelm https://helm.sh/\nHelmはk8sにおけるパッケージマネージャーのようなもです\nk8sのService, Deployment, ConfigMap, etcをひとつのまとまり(Chartと呼ばれる)として構成し、それらのk8sクラスタへのinstall/update/deleteなどの責務を担当してくれます\n公式や誰かの作ったChartをinstallするほか、自分たちの作ってるアプリケーションのChartを作成することでマニフェストファイルの共通化やdeploy/rollbackを簡単にすることができます\n当記事では後者の用途を前提として進めます\nHelmの基礎を理解頂いてる方は Template までスキップして頂けると、今回の本題はそちらですので\nInit Helmのインストール手順は公式を参照、以下はHelm/k8sをinstallしている前提で進めます\nChartのスケルトン生成 $ helm create first-app Creating first-app $ tree first-app/ first-app/ ├── Chart.yaml ├── charts ├── templates │ ├── NOTES.txt │ ├── _helpers.tpl │ ├── deployment.yaml │ ├── ingress.yaml │ ├── service.yaml │ └── tests │ └── test-connection.yaml └── values.yaml 3 directories, 8 files helm create \u0026lt;chart name\u0026gt; でChartのスケルトンを生成できます\n生成されるファイル/ディレクトリ   Chart.yaml\nChartの概要、対象のk8s API versionなどが記載されている\n  charts\nSubchart(自身のChartが依存するChart)が含まれるディレクトリ\nSubchartについての説明はこの記事では行いません(自分もまだ使ったことのない機能なので)\n  templates\n今回の本題、マニフェストファイルのTemplateが格納されているディレクトリ\nマニフェストファイルについての詳しい説明は後述\n  values.yaml\nTemplateで使える値のyaml\nこのファイルではデフォルト値を定義しておき、install/update時に環境に応じたファイルを渡すことでここで定義した値を差し替えることができる\n  デバッグ $ helm install . --debug --dry-run\nとすることで作成中のTemplateに変数を展開したマニフェストファイルをみることができます\nTemplate Chartを構成するk8sマニフェストはTemplateと呼ばれるファイルによって生成されます\nTemplateはその名の通りマニフェストファイルのテンプレートで変数を埋め込んだり、関数を呼び出すことで環境に応じて変更される部分を抽象化することができます\nこの項目ではTemplateで使える様々な構文について説明します\n基本的な構文 Templateにおいて何れの構文も {{ }} に囲まれて表記されます\n{{ }} 以外の部分はただのk8sマニフェストです、つまりただのyamlです\n(ちなみに Go言語のTemplate機能 から派生しているようです)\n中括弧内側の前後にダッシュ {{- -}} をつけることができ、前後の改行を含めた空白文字をトリムします\nhoge:{{- $piyo:=\u0026#34;aaa\u0026#34;}}- \u0026#34;fuga\u0026#34;# ↓↓展開されると↓↓hoge:- \u0026#34;fuga\u0026#34;コメント /* */ で囲まれた部分はコメント構文になります\n通常のプログラミング言語のコメントと同様で展開時には無視されます\n{{- /* a comment */ -}} 変数 変数には二種類あり、ルートオブジェクトからpathを辿って呼び出されるものとローカル変数の参照です\n「ルートオブジェクト」「ローカル変数」については勝手に名前をつけたものなので公式ではありません\n変数はそのまま参照先の値が展開されます\nルートオブジェクト Templateで呼び出せる様々な事前定義オブジェクトやvalues.yamlに定義された値を取り出すための Values オブジェクトへの参照を持つrootです\n後述する _helpers.tpl 内で定義できる名前付きtemplateや、range構文では呼び出し時に渡した値がルートオブジェクトとなります\n{{ . }} がルートオブジェクトそのものを表す記法となり、ここからpathを記載していきます\n# templates/service.yamlapiVersion:v1kind:Servicemetadata:name:{{.Values.myapp.serviceName}}---# values.yamlmyapp:serviceName:\u0026#34;myservice\u0026#34;Valuesの他にもルートオブジェクトには様々な事前定義オブジェクトがあり以下のドキュメントが一覧となります\nhttps://helm.sh/docs/chart_template_guide/#built-in-objects\nローカル変数 各Templateファイル内で変数を定義することができます\n{{- $volumeName:=\u0026#34;myvolume\u0026#34;-}}volumeMounts:- mountPath:/etc/{{$volumeName}}/name:{{$volumeName}}volumes:- name:{{$volumeName}}見ての通りだとは思いますが {{- $volumeName := \u0026quot;myvolume\u0026quot; -}} で変数に束縛し {{ $volumeName }} で展開できます\n関数 Template構文内では事前定義された様々な関数を使うことができます\n残念ながら定義の一覧のドキュメントは存在しないようです\nただし、Helm側で定義されている関数の他、以下の関数の多くが実装されているそうです\nhttp://masterminds.github.io/sprig/\nまた、事前定義オブジェクトの中にも定義されている関数があります( .Files.get など)\n関数の呼び出しは 関数名 引数1 [引数2 ...] という形になります\n関数はパイプ(|) を使うことでチェインすることができます\n{{ .Files.get \u0026quot;files/main.cf\u0026quot; | nindent 4}} 以下よく使う関数を抜粋して紹介します\n紹介の表記は 関数名 \u0026lt;引数1の型\u0026gt; [\u0026lt;引数2の型\u0026gt; ...] という形にします\nリファレンスがないので型といっても数値か文字列かオブジェクトとか、といった程度になってしまいますが…\n  nindent \u0026lt;numer\u0026gt; \u0026lt;string\u0026gt;\n第2引数に渡した文字列の各行の先頭に第1引数の数値分だけ半角スペース(つまりインデント)を埋め込みます\nyaml等の文字列を展開する場合にこの関数でインデントを調整することができます\n  toYaml\nオブジェクトをyaml形式で展開してくれます\nvalues.yamlに記載されているyamlを直接マニフェストファイルに展開したい場合などにこの関数を使います\n  # values.yamltest:hoge:fuga:piyo# deployment.yamlexpand:{{- nindent2(toYaml.Values.test)}}# ↓↓展開されると↓↓expand:hoge:fuga:piyo include \u0026lt;string\u0026gt; \u0026lt;object\u0026gt;\n_helpers.tpl に定義した名前付きtemplateを展開します\n第2引数のオブジェクトは名前付きtemplate側でのルートオブジェクトとして扱われ、基本的にはルートオブジェクトをそのまま渡すパターン {{ inculude \u0026quot;fugafuga\u0026quot; . }} が多いです\n以下のサンプルではあえてルートオブジェクト以外のものを渡してみます  # values.yamltest:hoge:fuga:piyo# _helpers.tpl{{- define\u0026#34;fugafuga\u0026#34;-}}- {{toYaml.-}}- {{toYaml.-}}{{- end}}# deployment.yamlexpand:{{- include\u0026#34;fugafuga\u0026#34;.Values.test.hoge|nindent2}}# ↓↓展開されると↓↓expand:- fuga:piyo- fuga:piyo tpl \u0026lt;string\u0026gt; \u0026lt;object\u0026gt;\n第1引数の文字列をTemplateとして解釈し、第2引数をルートオブジェクトとして展開します\n_helpers.tpl に定義しているものは include で展開すればTemplateとして解釈されるので\nこちらは外部ファイルを取ってきたあとに適用する場合が多いです\nTemplate構文を展開するだけなのでyaml以外の文字列でも適用は可能です  # values.yamlnginxValues:nginxUser:\u0026#34;nginx\u0026#34;# files/nginx.confuser{{.nginxUser}};http{# いろいろ}# configmap.yamldata:nginx.conf:|{{tpl(.Files.Get\u0026#34;files/nginx.conf\u0026#34;).Values.nginxValues|nindent4}}# ↓↓展開されると↓↓data:nginx.conf:| user nginx;http{# いろいろ} .Files.Get \u0026lt;string\u0026gt;\n外部からファイルを文字列として取り込みます\n第1引数はファイルパスでChartのルートディレクトリ( Chart.yaml の置いてあるディレクトリ)からの相対パスを記載します  アクション 関数のほか、Templateを制御するためいくつかのキーワードが用意されています\n一般的なプログラミング言語でいう if や for などにあたります、これをHelmではアクションと呼びます\nif/else 特に語ることのない一般的なif文です\n値が以下の場合にはすべて false として判定されます\nhttps://helm.sh/docs/chart_template_guide/#if-else\nA pipeline is evaluated as false if the value is: a boolean false a numeric zero an empty string a nil (empty or null) an empty collection (map, slice, tuple, dict, array) 注意点としてダッシュ付きの中括弧を使用することを推奨するくらいです\nspec: replicas: {{ if .Values.safety -}} 2 {{- else -}} 1 {{- end -}} with 引数に渡したオブジェクトをルートオブジェクトとしたスコープを展開できます\n引数に渡したオブジェクトが if/else アクションで紹介したfalseにあたる値の場合はwithブロック自体が展開されません、つまり簡易的な if としても使用できます\nwithブロック内で .Files オブジェクトなどの事前定義オブジェクトを参照する場合は外側で変数に束縛しましょう、このテクニックは range アクションでも使用できます\n# values.yamlconfigPaths:nginxConfPath:\u0026#34;files/nginx.conf\u0026#34;# configmap.yaml{{- $files=.Files-}}data:{{- with.Values.configPaths-}}nginx.conf:|{{$files.get.nginxConfPath|nindent4}}{{- end-}}range 引数に渡した配列でループを回します\nループ内のスコープでは配列の値自体がルートオブジェクトとなります\n# values.yamlconfigPaths:- key:nginx.confpath:\u0026#34;files/nginx.conf\u0026#34;- key:postfix.main.cfpath:\u0026#34;files/main.cf\u0026#34;# comfigmap.yaml{{- $files=.Files-}}data:{{- range.Values.configPaths-}}{{.key }}:|{{$files.get.path|nindent4}}{{- end-}}# ↓↓展開されると↓↓data:nginx.conf:| # nginx.confの内容main.cf:| # main.cfの内容template _helpers.tpl に定義してある名前付きtemplateを展開します\nただし、include関数と違いルートオブジェクトを渡すことができません\n_helpers.tpl Chart内で共通で使うことのできるテンプレートスニペットを定義します、これは「名前付きテンプレート」と呼ばれます\nvalues.yaml が差し替え可能な変数、ローカル変数が定義したTemplateファイル内でのみ使える変数、_helpers.tplはチャート内で自由に使える変数、という形に捉えることができます\ndefine アクションを使うことで名前付きテンプレートを定義することができます\nもちろん、テンプレートなので定義内で変数を展開したり、関数やアクションを使用することもできます\n(ただし、呼び出し側で想定通りのオブジェクトを渡す必要があります、templateアクションではなくincluede関数を使う必要もあります)\n{{- define \u0026quot;myapp.namespace\u0026quot; -}} {{ .Chart.Name }}-space {{- end }}  Helm Template構文における基本的な構文は以上となります\nひとまずこれだけ覚えていれば問題なくHelm Templateを読み書きできると思います\n少し特殊なものが多いのでGo Templateを触れていない(自分もそうだったのですが)人間から見るとなかなかつらいもの、特に関数周りは公式ドキュメントに記載や一覧がないのでとっつきにくいと感じたので今回の記事を書かせて頂きました\nこの記事が誰かの役に立つことを願います\n"});index.add({'id':2,'href':'/blog/tags/k8s/','title':"k8s",'parent':"Tags",'content':""});index.add({'id':3,'href':'/blog/','title':"Kerfume Blog",'parent':'','content':""});index.add({'id':4,'href':'/blog/posts/','title':"Posts",'parent':"Kerfume Blog",'content':""});index.add({'id':5,'href':'/blog/tags/','title':"Tags",'parent':"Kerfume Blog",'content':""});index.add({'id':6,'href':'/blog/posts/helm-tips/','title':"Helm Tips",'parent':"Posts",'content':"この記事は FOLIO Advent Calendar 2020 8日目の記事です\nFOLIOでは現在k8sを利用した新しいアプリケーション基盤を検証しています\nその中でk8sマニフェストを管理する上で欠かせないツール Helm についての知見を少しだけ共有しようと思います\nHelmって？ https://helm.sh/\nk8s上で動くパッケージマネージャ\nパッケージマネージャとはあるinfraの上で動くアプリケーションの\nインストール/アンインストールの管理などを行ってくれるソフトウェアのことを指します\nk8sというinfraの上でhelmというパッケージマネージャーが扱う「アプリケーション」は\nマニフェストファイルの集合となります\nhelmの世界ではパッケージはChartと呼ばれ、Chartリポジトリと呼ばれるhttp(s) serverにて管理されます\n標準では stableリポジトリ が用意されていますが\nユーザ側で用意した独自リポジトリも使用することが可能です\nHelmのChart構造やtemplate構文については以下の記事を参照ください\nhttps://keisunagawa.github.io/blog/posts/helm-template/\nLocal Chart helmはChartリポジトリからChartをインストールする他、localに存在するChartをディレクトリ指定で\n直接インストールすることも可能です\nこの方法は検証段階や、privateなChartリポジトリを建てる環境が存在しない場合などに役に立ちます\nInstall Tips helm Chartは helm install \u0026lt;release名\u0026gt; \u0026lt;chart名\u0026gt; コマンドによってk8sクラスタ上へインストールします\nまたインストール済みのChartについては helm upgrade コマンドでversionを更新することができます\n\u0026lt;release名\u0026gt; が違う場合は同じChartを複数インストールすることも可能です、ただしこの場合別名Chart同士でresource名の\nコンフリクトが発生しないことを前提としています\nversionというのはChart自身のversionのことでdocker imageのversionなどはChartのversionもしくはinstall時に\n引き渡す values.yaml の値によって決定されます、つまりChartの内容次第ということになります\nhelm upgrade --install とすることでinstall操作とupgrade操作を同時に行えます\nこれは新規Chartの場合install、インストール済みChartの場合はupgradeを行うというコマンドになります\nLocal Chartは helm install \u0026lt;release名\u0026gt; \u0026lt;chart dir\u0026gt; とすることでインストールすることができます\n以下install(upgrade)時によく使う引数をいくつかpickupします\n   flag      --create-namespace -nで指定したnamespaceが存在しない場合自動的に作成します   --atomic 何れかのマニフェスト適用に失敗した場合、install(upgrade)コマンド発行前の状態に戻します   --timeout install(upgrade)タイムアウトまでの時間を設定します外部リソースと連動したk8s resourceを発行するChartなどはタイムアウト値を伸ばすことを推奨します   --wait Podリソースなどが稼働状態になるのまでwaitしますただし、timeout時間までに稼働状態にならなかった場合はfailとなります   --values -f 利用するvalues.yamlを引き渡します複数引き渡すことも可能で、その場合同一キーは後勝ちとなります    依存Chart Chartは他のChartへ依存することができ、そのChartをインストールした場合は依存Chartも一緒にインストールされます\n依存定義はChart.yamlに記載されます(古いChartであれば requirements.yaml というファイルに記載されていますが、こちらは現在 deprecated です)\n何も指定しない場合、依存Chartは常にインストールされますが、condition もしくは tags キーを利用することでユーザ側に利用の有無を移譲することができます\n依存chartの条件については少し複雑なので以下のソースを参照しながら説明します\nよければvalues.yamlの値を書き換え、実際の挙動を確認してください\nhttps://github.com/keiSunagawa/helm-chart-playground/tree/master/dependency-example\ncondition https://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/Chart.yaml#L9\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/values.yaml#L2\ndependencies:- name:sub-chart-1version:\u0026#34;0.1.0\u0026#34;repository:\u0026#34;file://../sub-chart-1\u0026#34;condition:subChart1.enabledvaluesの値がboolであるキーを指定することで依存の利用有無を制御できます\n純粋なbool値のみを利用できnotやor/and演算を利用することはできません\nキーに紐づく値がnullの場合、キーが存在しない場合はtrueとして判定されます\nまた、カンマ区切りで複数の値を指定することができ、その場合は先頭から順に検査され\nnullでない一番最初の値 が利用されます\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/Chart.yaml#L18\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/values.yaml#L7\ncondition:subChart3.enabled,subChart3.devこの場合は subChart3.enabled がnullである場合は subChart3.dev が代わりに参照されます\nどちらのキーもnullだった場合はtrueとして判定されます\ntags https://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/Chart.yaml#L13\nhttps://github.com/keiSunagawa/helm-chart-playground/blob/master/dependency-example/main-chart/values.yaml#L4\n- name:sub-chart-2version:\u0026#34;0.1.0\u0026#34;repository:\u0026#34;file://../sub-chart-2\u0026#34;tags:- subChart2valuesの値がboolであるキーを配列で渡すことで condition より比較的複雑な条件分岐ができます\nvalues.yaml の tags.xxx のキーを参照し、対象キーがnullまたはtrueであった場合に依存Chartがインストールされます\n複数指定することもでき、複数指定した場合は以下の条件に従いインストールされます\n(公式ドキュメントが見当たらなかったため、v3.1.2 で検証した結果を載せています)\n インストールされる  何れかのキーがtrueの場合 すべてのキーがnullの場合   インストールされない  falseのキーが存在し、他のキーがnullの場合 全てのキーがfalseの場合    マニフェストの検証 helm template コマンドを利用することでk8sクラスタへChartをインストールすることなくマニフェストの検証をすることができます\n-f で本番環境で利用する values.yaml を引き渡せば本番適用時のものとほぼ同様のマニフェストを取得することができます\nhelm template コマンドはtemplateが正しいyamlに展開されなかった場合にfailします\nこの場合は --debug 引数を与えてあげることで不正なyamlを確認することができます\n出力は純粋なyamlになるので、yq などを利用して検証を行うことができます\n# Kindの一覧を取得する $ helm template . | yq r -d\u0026#39;*\u0026#39; --printMode pv - \u0026#39;kind\u0026#39; | uniq kind: ServiceAccount kind: Service kind: Deployment kind: Pod  終わりに helmはk8sを使う上で欠かせないツールです\n今回紹介した機能の他にもライフサイクルhookとなる helm hook や、インストールしたChartをロールバックする\n機能などが提供されており、単なるパッケージマネージャ以上の働きを期待することができます\nその他、FOLIO Advent Calendar 2020 20日目にてArgoCDというk8sで動くCDツールの話を\n書く予定ですが、ArgoCDとhelmを連携させることでさらに強力なツールとなるので、よければぜひそちらの記事も読んでいただけると幸いです。\n"});index.add({'id':7,'href':'/blog/categories/','title':"Categories",'parent':"Kerfume Blog",'content':""});})();